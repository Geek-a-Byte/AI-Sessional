# -*- coding: utf-8 -*-
"""A * Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q_90HU3itXO1q9GuQxrBszpN3OoHzw-2
"""

import numpy as np

class Node:

    def __init__(self,puzzleBox=None):
        self.parent=None
        self.g=0
        self.puzzleBox=puzzleBox
        if(self.puzzleBox==None):
            self.puzzleBox= [
                              [7,2,4],       
                              [5,0,6],
                              [8,3,1],
                            ]

        self.puzzleBox=np.array(self.puzzleBox)

    def moveUp(self):
        zeroPos=np.where(self.puzzleBox==0)
        zeroPosR,zeroPosC=zeroPos
        otherPosR=zeroPosR-1
        otherPosC=zeroPosC
        if(otherPosR<0):
            return
        temp=self.puzzleBox[otherPosR,otherPosC]
        self.puzzleBox[otherPosR,otherPosC]=self.puzzleBox[zeroPosR,zeroPosC]
        self.puzzleBox[zeroPosR,zeroPosC]=temp
    
    def moveDown(self):
        zeroPos=np.where(self.puzzleBox==0)
        zeroPosR,zeroPosC=zeroPos
        otherPosR=zeroPosR+1
        otherPosC=zeroPosC
        if(otherPosR>2):
            return
        temp=self.puzzleBox[otherPosR,otherPosC]
        self.puzzleBox[otherPosR,otherPosC]=self.puzzleBox[zeroPosR,zeroPosC]
        self.puzzleBox[zeroPosR,zeroPosC]=temp
    
    def moveLeft(self):
        zeroPos=np.where(self.puzzleBox==0)
        zeroPosR,zeroPosC=zeroPos
        
        otherPosR=zeroPosR
        otherPosC=zeroPosC-1
        
        if(otherPosC<0):
            return
        temp=self.puzzleBox[otherPosR,otherPosC]
        self.puzzleBox[otherPosR,otherPosC]=self.puzzleBox[zeroPosR,zeroPosC]
        self.puzzleBox[zeroPosR,zeroPosC]=temp

    def moveRight(self):
        zeroPos=np.where(self.puzzleBox==0)
        zeroPosR,zeroPosC=zeroPos
        
        otherPosR=zeroPosR
        otherPosC=zeroPosC+1
        
        if(otherPosC>2):
            return
        temp=self.puzzleBox[otherPosR,otherPosC]
        self.puzzleBox[otherPosR,otherPosC]=self.puzzleBox[zeroPosR,zeroPosC]
        self.puzzleBox[zeroPosR,zeroPosC]=temp

    
    #overriding the functions for comparison
    def __hash__(self):
        hash=0
        count=1
        for i in range(3):
            for j in range(3):
                hash=hash+count*self.puzzleBox[i][j]
                count=count+1
        return int(hash)

    def __eq__(self,other):
        if(other==None):
            return False
        
        equal=True        
        for i in range(3):
            for j in range(3):
                if(self.puzzleBox[i][j]==other.puzzleBox[i][j]):  
                    continue
                else:
                    equal=False
                    break
        return equal

    def display(self):
        print('*************************')
        for i in range (3):
            for j in range (3):
                print(f'({self.puzzleBox[i,j]})',end='')
            print('')
        print('*************************')

node1=Node()
node2=Node()
node2.moveLeft()
node1.display()
node2.display()

node1==node2
mySet=set()
mySet.add(node1)
mySet.add(node2)
print(mySet)

def h1(node):
    goalPuzzleBox=[[0,1,2],       
                   [3,4,5],
                   [6,7,8]]
    goalPuzzleBox=np.array(goalPuzzleBox)
    currentPuzzleBox=node.puzzleBox
    totalDist=0
    for i in range(9):
        if(i==0): 
            continue
        
        currentPosition=np.where(currentPuzzleBox==i)
        goalPosition=np.where(goalPuzzleBox==i)
        
        currR,currC=currentPosition[0],currentPosition[1]
        goalR,goalC=goalPosition[0],goalPosition[1]
        
        tileDist=sum(abs(currR-goalR),abs(currC-goalC))
        totalDist=totalDist+tileDist
    return totalDist

node=Node(
    puzzleBox= [[7,2,4],       
                [5,0,6],
                [8,3,1]]
)
node.display()
h1(node)

node1=Node(puzzleBox= [[1,0,2],       
                [3,4,5],
                [6,7,8],])
print(h1(node1))
node2=Node(puzzleBox= [[0,7,2],       
              [3,4,5],
              [6,1,8],])
print(h1(node2))
node3=Node(puzzleBox= [[7,2,4],       
                [5,0,6],
                [8,3,1],])
print(h1(node3))
nodeList=[]

nodeList.append(node3)
nodeList.append(node1)
nodeList.append(node2)

([x.display() for x in nodeList])

nodeList.sort(key=lambda n: h1(n)+n.g)

nodeTest=Node(puzzleBox=  [[0,7,2],       
              [3,4,5],
              [6,1,8]])
nodeTest.g=10
x=nodeList.index(nodeTest)
nodeList[x].display()
nodeList[x].g

print([x.puzzleBox for x in nodeList])

def goalTest(node):
    goalPuzzleBox=[[0,1,2],       
                [3,4,5],
                [6,7,8]]
    goalPuzzleBox=np.array(goalPuzzleBox)
    if(np.array_equal(goalPuzzleBox,node.puzzleBox)):
        return True
    else:
        return False

node1=Node(puzzleBox= [[0,1,2],       
                [3,4,5],
                [6,7,8],])
goalTest(node1)

import sys
sys.setrecursionlimit(10000)

mylist=['a','b','c','d','e']
x=mylist.pop(0)
print(x)

import copy

def aStarSearch():
  initialNode=Node(puzzleBox= [[1,2,3],       
                [0,4,6],
                [7,5,8],])
  #initialNode=Node()
  # if goalTest(initialNode)==True :
  #     return initialNode

  frontier=[] # a queue
  frontier.append(initialNode)
  
  explored= set()
  
  while(True):      
      # If frontier is empty then return failure
      if(len(frontier)==0):
          None
      #getting current node
      frontier.sort(key=lambda n: h1(n)+n.g)
      node=frontier.pop(0)
      #node.display()
      if goalTest(node)==True :
          return node     
      
      #node.display()
      #adding the node toexplored set
      explored.add(node)

      # for each action available we are now generating child
      child1=copy.deepcopy(node)
      child1.moveUp()
      child1.g=child1.g+1
      child1.parent=node

      child2=copy.deepcopy(node)
      child2.moveDown()
      child2.g=child2.g+1
      child2.parent=node

      child3=copy.deepcopy(node)
      child3.moveLeft()
      child3.g=child3.g+1
      child3.parent=node

      child4=copy.deepcopy(node)
      child4.moveRight()
      child4.g=child4.g+1
      child4.parent=node
                  
      childList=[child1,child2,child3,child4]
      
      for child in childList:
          if((child  in frontier)==False and (child in explored)==False):
              child.parent=node              
              frontier.append(child)            
          elif(child in frontier):
              index=frontier.index(child)
              inFrontierNode=frontier[index]
              if(h1(child)+child.g<h1(inFrontierNode)+inFrontierNode.g):
                  frontier[index]=child


x=aStarSearch()
print(x)

x.parent

def printPath(node):
    if(node==None):
        return
    printPath(node.parent)
    node.display()

printPath(x)