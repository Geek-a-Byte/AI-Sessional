# -*- coding: utf-8 -*-
"""Flood it.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-l-UXu9ub-1TCnJ8jpONtpLG9KxWr72U
"""

# Flood It
# http://unixpapa.com/floodit/?sz=14&nc=6

# using NumPy here for handling 2D arrays.
import numpy as np

# queue module is needed for queue and priority queue's
import queue as queue

# using mathplotlib to draw the color matrix
import matplotlib.pyplot as plt

# using hashlib to hash game states
from hashlib import sha1

# using time module for calcuating time needed to solve the puzzle
import time

# using copy module for copying numpy arrays for making new states
import copy

# unit class represents a collection of same colored blocks. 

class unit:
    def __init__(self, blocks, color):
        # Each row of this 2D array has 2 integers(x,y cordinates). They indicate a block in the game board. 
        # These positions are positions of a unit of blocks in the game board
        self.blocks = blocks

        # This represents the color of the connected component
        self.color = color
    
    # Adds a block to the unit
    def add(self, tup):
        self.blocks = np.concatenate((self.blocks, [tup]))
    
    # Checks whether two units are adjacent or not.
    def adj(self, other):
        for i in self.blocks:
            for j in other.blocks:
                [pi, qi] = i
                [pj, qj] = j
                if abs(pi - pj) + abs(qi - qj) == 1:
                    return True
        return False
    
    # Merges two units
    def merge(self, other):
        self.blocks = np.concatenate((self.blocks, other.blocks))

# state class represents the game board

class state:

    # Stores the hiuristic type
    hiuristic_type = 0
    
    def __init__(self, n, m, corner, others, depth):
        # number of rows in the board - n
        self.n = n

        # number of columns in the board - m 
        self.m = m

        # stores the unit that contains the upper-left block of the game board, object type unit
        self.corner = corner

        # Stores the all the other units of the game board other than the corner - Array of units
        self.others = others

        # depth of the state in the dfs tree
        self.depth = depth

        # returns a hash value for the state. we can identify a game board uniquely only with the color of the corner unit and 
        # the positions of blocks of the corner unit. So sha1 hash was applied on these values to get the hash.
        self.hash = sha1(self.corner.blocks)
        self.hash.update(self.corner.color)
        self.hash.hexdigest()
    
    # returns the number of connected units of blocks in the board other than the corner unit
    def num_comp(self):
        return 1 + len(self.others)
    
    # returns the number of distinct colors in the board
    def num_color(self):
        cols = set()
        cols.add(self.corner.color)
        for c in self.others:
            cols.add(c.color)
        return len(cols)
    
    # returns depth of the state in the dfs tree
    def get_depth(self):
        return self.depth
    
    # checks whether all the cell of the board has same color or not where self.others would be zero
    def is_terminal_state(self):
        return self.num_comp() == 1
    
    # changes the color of the corner unit and increases its size accordingly. This mimics a game move and returns
    def change_color(self, new_color):
        new_corner = copy.deepcopy(self.corner)
        new_corner.color = new_color
        new_others = []
        for c in self.others:
            if c.color == new_color and self.corner.adj(c):
                new_corner.merge(copy.deepcopy(c))
            else:
                new_others.append(c)
        return state(self.n, self.m, new_corner, new_others, self.depth + 1)
    
    # returns a set of colors that are adj to the corner unit. excludes the color of the corner unit
    def find_candidates(self):
        ret = set()
        for c in self.others:
            if self.corner.adj(c):
                ret.add(c.color)
        return ret
    
    # shows the state as an image form
    def get_image(self):
        board = np.full((self.n, self.m), 0)
        for tup in self.corner.blocks:
            [i, j] = tup
            board[i, j] = self.corner.color
        for c in self.others:
            for tup in c.blocks:
                [i, j] = tup
                board[i, j] = c.color
        plt.matshow(board)
        plt.show()
    
    # return hash of the state
    def get_hash(self):
        return self.hash
    
    # returns hiuristic value of the state
    def hiuristic(self):
        if state.hiuristic_type == 0:
            return self.num_comp()

        if state.hiuristic_type == 1:
            return self.num_color()

        if state.hiuristic_type == 2:
            return -2 * self.get_depth()
    
    # to insert the states in the priority queue as per the hiuristics , less than and equal operators are overridden
    def __lt__(self, other):
        return self.get_depth() + self.hiuristic() < other.get_depth() + other.hiuristic()
    
    def __eq__(self, other):
        return self.get_depth() + self.hiuristic() == other.get_depth() + other.hiuristic()

# board = np.random.randint(3, size=(6,6)) - a 6x6 board with randomized colors between 0-2

# adding blocks of the same color to a unit - making a connected unit through dfs
def dfs(board, vis, i, j, comp):
    vis[i, j] = True
    comp.add((i, j))
    n, m = board.shape
    if i > 0 and vis[i-1, j] == False and board[i][j] == board[i-1, j]:
        dfs(board, vis, i-1, j, comp)
    if j > 0 and vis[i, j-1] == False and board[i][j] == board[i, j-1]:
        dfs(board, vis, i, j-1, comp)
    if i < n-1 and vis[i+1, j] == False and board[i][j] == board[i+1, j]:
        dfs(board, vis, i+1, j, comp)
    if j < m-1 and vis[i, j+1] == False and board[i][j] == board[i, j+1]:
        dfs(board, vis, i, j+1, comp)

#  make_state takes a game board as argument and returns a state     
def make_state(board):
    n, m = board.shape
    vis = np.full((n, m), False)
    corner = unit(np.empty((0, 2), int), board[0, 0])
    dfs(board, vis, 0, 0, corner)
    
    others = []
    for i in range(0, n):
        for j in range(0, m):
            if vis[i, j] == False:
                new_comp = unit(np.empty((0, 2), int), board[i, j])
                dfs(board, vis, i, j, new_comp)
                others.append(new_comp)
    return state(n, m, corner, others, 0)

# Now we'll write a function called solve which takes board and a hiuristic_type as arguments and returns solution to the game.
def a_star(board, hiuristic_type):
    start = time.time()
    state_cnt = 0
    prev = {}
    state.hiuristic_type = hiuristic_type
    pq = queue.PriorityQueue()
    pq.put(board) # inserting the first state of the board in the priority queue
    state_cnt += 1
    prev[board.get_hash()] = None # to uniquely identify the states we use hash
    while not pq.empty():
        u = pq.get() # getting the first state of pq at every stage
        if u.is_terminal_state(): # checks whether all the cell of the board has same color or not, where self.others would be zero
            print("The initial game board was:")
            board.get_image()
            print("With hiuristic type {}, {} steps were needed to solve the game".format(hiuristic_type, u.get_depth())); # the depth count refers the count of change_color() calls for this state u.
            now = u
            result = []
            for it in range(0, u.get_depth()+1):
                result.append(now) # appending from leaf to root state
                now = prev[now.get_hash()] 
            end = time.time()
            print("Total time taken to solve was {} seconds".format(end - start));
            print("Total number of state visited is {}".format(state_cnt));
            for step in reversed(result): # printing from root to leaf
                step.get_image()
            return

        # find_candidates() - returns a set of colors that are adj to the corner unit. excludes the color of the corner unit
        # change_color() - changes the color of the corner unit and increases its size accordingly. This mimics a game move and returns
        for color in u.find_candidates():
            v = u.change_color(color)
            if v.get_hash() not in prev:
                prev[v.get_hash()]=u
                state_cnt += 1
                pq.put(v)

board = np.random.randint(3, size=(6,6))
st = make_state(board)
a_star(st, 0);
a_star(st, 1);
a_star(st, 2);